# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xRrFqvT1WfI9v7aeD2wW7pseIcA0noS1

THEORY QUESTION

Q1. What is Object-Oriented Programming (OOP)?

Ans:
Object-Oriented Programming (OOP) is a programming method that organizes software design around objects, which represent real-world entities. These objects are created from classes, which define their structure and behavior. OOP focuses on four main principles: encapsulation (bundling data and methods together), inheritance (reusing code from existing classes), polymorphism (methods behaving differently based on the object), and abstraction (hiding unnecessary details). OOP makes code more modular, reusable, and easier to maintain. It helps in building complex software systems by breaking them into smaller, manageable pieces. Languages like Java, Python, and C++ use OOP extensively.

The key principles of OOP are:

Encapsulation: Bundling data and methods together, restricting access to internal details.

Inheritance: Creating new classes from existing ones to promote code reuse.

Polymorphism: Allowing objects to be treated as instances of their parent class, enabling method overriding.

Q2. What is a class in OOP?

Ans:A class in Object-Oriented Programming (OOP) is a blueprint or template used to create objects. It defines the structure and behavior that the objects created from it will have. A class contains:

Attributes (also called data members or properties) ‚Äì variables that hold the state of the object.

Methods (also called member functions) ‚Äì functions that define the behavior or actions the object can perform.

‚úÖ Example (in Python):
python
Copy
Edit
class Car:
    def __init__(self, brand, color):
    self.brand = brand
    self.color = color

    def start_engine(self):
    print(f"{self.brand} engine started!")
Here, Car is a class with attributes brand and color, and a method start_engine().

Q3:What is an object in OOP?

Ans:In Object-Oriented Programming (OOP), an object is a fundamental unit that represents a real-world entity. It is created from a class, which serves as a blueprint or template. An object consists of attributes (also known as properties or data members) and methods (functions that define behavior). When a class is defined, no memory is allocated until an object is created from it. For example, if you have a class Car, you can create multiple objects like car1 = Car("Toyota") and car2 = Car("Honda"), each having its own unique data.

Objects help organize code by combining data and functionality together, promoting the OOP principles of encapsulation, abstraction, inheritance, and polymorphism. Each object maintains its own state, and can perform actions using its methods. Objects interact with each other to build complex programs. They are reusable, modular, and make code more maintainable, readable, and aligned with real-life problem-solving.

Q4. What is the difference between abstraction and encapsulation?

Ans:Abstraction and encapsulation are both fundamental concepts in Object-Oriented Programming (OOP), but they serve different purposes.

*Abstraction means hiding complex implementation details and showing only the necessary features to the user. It focuses on what an object does, not how it does it. For example, when you use a smartphone, you know how to press buttons, but you don‚Äôt see the internal circuits ‚Äî that‚Äôs abstraction. It is usually achieved using abstract classes or interfaces in programming.

*Encapsulation, on the other hand, means wrapping data and methods into a single unit (class) and restricting direct access to some parts of the object using access modifiers. It focuses on how data is protected from outside interference. In Python, this is done using private variables (__variable) and getter/setter methods.

In short:

Abstraction hides implementation complexity

Encapsulation hides object‚Äôs internal data for security and control.

Both improve modularity and code safety.

Q5. What are dunder methods in Python?

Ans:Dunder methods in Python, also known as magic methods or special methods, are built-in methods that start and end with double underscores (hence ‚Äúdunder‚Äù ‚Äì short for double underscore). These methods allow you to customize the behavior of your objects and define how they interact with Python‚Äôs built-in operations.

For example:

    __init__() initializes an object (constructor)

    __str__() defines what is returned when the object is printed


These methods let you implement features like operator overloading, string representation, comparison, and more.

Dunder methods make custom classes behave like built-in types, enhancing flexibility and readability.

Q6. Explain the concept of inheritance in OOP.

Ans:Inheritance is a core concept in Object-Oriented Programming (OOP) that allows a class (child/subclass) to inherit properties and behaviors (attributes and methods) from another class called the parent (superclass). This promotes code reuse, reduces redundancy, and supports hierarchical classification.

For example, a general class Animal may have a method speak(). A subclass Dog can inherit this method and also have additional features like bark(). The Dog class doesn‚Äôt need to rewrite the speak() method ‚Äî it reuses it from Animal.

In Python, inheritance is written as:

python

Copy

Edit

    class Animal:
    def speak(self):
    print("Animal speaks")

    class Dog(Animal):
    def bark(self):
    print("Dog barks")
Python also supports multiple inheritance, where a class can inherit from more than one parent class.

Inheritance helps organize code, make it more modular, and allows for polymorphism, where the same method behaves differently in different subclasses.

Q7. What is polymorphism in OOP?

Ans:Polymorphism is a key concept in Object-Oriented Programming (OOP) that means ‚Äúmany forms.‚Äù It allows the same method or operation to behave differently depending on the object that calls it. Polymorphism enhances flexibility, extensibility, and supports code reusability.

There are two main types:

Compile-time polymorphism (method overloading ‚Äì not supported natively in Python)

Run-time polymorphism (method overriding ‚Äì commonly used in Python)

In Python, polymorphism is often achieved through method overriding, where a subclass provides its own version of a method defined in its parent class.

Example:

python
Copy
Edit

class Animal:
    def speak(self):
    print("Animal sound")

class Dog(Animal):
    def speak(self):
    print("Woof")

class Cat(Animal):
    def speak(self):
    print("Meow")

for animal in [Dog(), Cat()]:
    animal.speak()
Each object responds differently to the same speak() method. This shows how polymorphism enables writing more general and maintainable code.

Q8. How is encapsulation achieved in Python?

Ans:Encapsulation in Python is the process of bundling data (attributes) and the methods that operate on that data into a single unit called a class, and then restricting direct access to some of the object's internal parts. This is done to protect the object‚Äôs integrity and prevent unintended interference or misuse.

In Python, encapsulation is achieved through:

Access modifiers:

Public (name) ‚Äì accessible from anywhere.

Protected (_name) ‚Äì intended for internal use (by convention).

Private (__name) ‚Äì name mangled to prevent direct access.

Getter and Setter methods:
These allow controlled access to private attributes.

Example:

python
Copy
Edit

class Account:
    def __init__(self):
        self.__balance = 0

    def deposit(self, amount):
        self.__balance += amount

    def get_balance(self):
        return self.__balance
Here, __balance is private, and access is controlled via get_balance() and deposit(). This ensures data security and integrity.

Q9. What is a constructor in Python?

Ans:A constructor in Python is a special method used to initialize objects when a class is instantiated. It is defined using the __init__() method. The constructor is automatically called when a new object is created from a class, allowing you to set initial values for the object‚Äôs attributes.

The first parameter of a constructor is always self, which refers to the current object. You can also pass additional arguments to set custom values during object creation.

Example:

python
Copy
Edit
class Student:

    def __init__(self, name, age):
    self.name = name
    self.age = age

    s1 = Student("Amit", 20)
    print(s1.name)  # Output: Amit
In this example, the constructor sets the name and age for each new Student object.

Constructors improve code readability and ensure that objects always start with a valid state. Python does not require explicit constructor calls‚Äî__init__() is triggered automatically upon object creation.

Q10. What are class and static methods in Python?

Ans:In Python, both class methods and static methods are used to define functions inside a class that are not bound to individual object instances.

üîπ Class Method:

Defined using the @classmethod decorator.

Takes cls as the first parameter (refers to the class, not the object).

Can access or modify class-level data.

Useful for factory methods or tracking class-wide changes.

üîπ Static Method:

Defined using the @staticmethod decorator.

Takes no special first argument (neither self nor cls).

Cannot access instance or class-level data.

Used for utility/helper functions related to the class.

Example:

python
Copy
Edit
class Math:

    count = 0

    @classmethod
    def increment(cls):
    cls.count += 1

    @staticmethod
    def add(a, b):
    return a + b
Class methods are tied to the class, static methods are independent of both the class and object, yet logically grouped with the class.

Q11. What is method overloading in Python?

Ans:Method overloading is a concept in Object-Oriented Programming where multiple methods in the same class share the same name but differ in the number or type of parameters. This allows a single method name to perform different tasks based on the arguments passed.

However, Python does not support traditional method overloading like some other languages (e.g., Java or C++). In Python, if you define multiple methods with the same name in a class, only the last one is retained, as it overwrites the previous ones.

To achieve similar functionality, default arguments or variable-length arguments (*args, **kwargs) are used.

Example:

python
Copy
Edit

    class Greet:
    def hello(self, name=None):
    if name:
    print(f"Hello, {name}!")
    else:
    print("Hello!")

    g = Greet()
    g.hello()        # Output: Hello!
    g.hello("Amit")  # Output: Hello, Amit!
This way, Python simulates method overloading using conditional logic.

Q12. What is method overriding in OOP?

Ans:Method overriding is an Object-Oriented Programming (OOP) concept where a subclass provides a specific implementation of a method that is already defined in its parent class. It allows the subclass to modify or extend the behavior of the inherited method to better suit its own needs.

To override a method, the subclass simply defines a method with the same name, parameters, and return type as the one in the parent class. When the method is called on an object of the subclass, the overridden method is executed, not the one in the parent.

Example:

python
Copy
Edit

    class Animal:
    def speak(self):
    print("Animal speaks")

    class Dog(Animal):
    def speak(self):
    print("Dog barks")

    d = Dog()
    d.speak()  # Output: Dog barks

In this example, Dog overrides the speak() method of Animal. Method overriding supports polymorphism and makes OOP more flexible and powerful.

Q13. What is a property decorator in Python?

Ans:The @property decorator in Python is used to convert a method into a read-only property, allowing access to methods like attributes. It provides a clean and Pythonic way to implement getter, setter, and deleter functions without explicitly calling them.

Using @property, you can define a method that can be accessed like a variable, which is useful for encapsulation and data validation.

Example:

python
Copy
Edit

    class Circle:
    def __init__(self, radius):
    self._radius = radius

    @property
    def area(self):
    return 3.14 * self._radius ** 2
Now, you can access area like an attribute:

python
Copy
Edit

    c = Circle(5)
    print(c.area)  # Output: 78.5
You can also use @<property>.setter to allow updates and @<property>.deleter to delete a property.
@property improves code readability, encapsulation, and helps control access to private attributes in a clean, object-oriented way.

Q14. Why is polymorphism important in OOP?

Ans:Polymorphism is important in Object-Oriented Programming (OOP) because it allows objects of different classes to be treated as objects of a common superclass. This enhances flexibility, scalability, and reusability in code. Here's why it's important:

‚úÖ 1. Code Reusability
You can write generic code that works on different data types or classes.

Example: A function can accept an object of a superclass and still work with any of its subclasses.

‚úÖ 2. Flexibility and Maintainability
It‚Äôs easier to change or extend parts of the program without modifying the existing code.

Example: Add a new subclass without changing the code that uses the superclass type.

‚úÖ 3. Improves Readability and Organization
Reduces duplicate code by defining shared behaviors in the base class and overriding only what‚Äôs necessary in child classes.

‚úÖ 4. Enables Dynamic Method Dispatch (Runtime Polymorphism)
The correct method is called at runtime depending on the object's actual type, not the reference type.

Example: You can override a method in subclasses to behave differently while using the same method name.

Q15. What is an abstract class in Python?

Ans:An abstract class in Python is a class that cannot be instantiated directly. It is meant to be a blueprint for other classes, and it typically contains one or more abstract methods‚Äîmethods that are declared but not implemented in the abstract class.

üìå Key Points:
Abstract classes are defined using the abc (Abstract Base Class) module.

They can contain abstract methods and concrete methods (methods with implementation).

You cannot create objects of an abstract class.

A subclass must implement all abstract methods, or it will also be considered abstract.

üß† Why Use Abstract Classes?

To enforce a common interface across multiple subclasses.

To define a template that child classes must follow.

    from abc import ABC, abstractmethod

    class Animal(ABC):  # Abstract class
    @abstractmethod
    def make_sound(self):  # Abstract method
    pass

    def sleep(self):  # Concrete method
    print("Sleeping...")

    class Dog(Animal):
    def make_sound(self):
    print("Bark")

    # animal = Animal()      # ‚ùå Error: can't instantiate abstract class
    dog = Dog()               # ‚úÖ
    dog.make_sound()          # Output: Bark
    dog.sleep()               # Output: Sleeping...

Q16. What are the advantages of OOP?

Ans:Object-Oriented Programming offers many benefits that make software development more organized, scalable, and efficient. Here are the key advantages:

1. Modularity

  *Code is divided into objects and classes, which act as independent modules.

  *Makes large projects easier to organize and manage.

2. Reusability

 *Through inheritance, classes can reuse code from other classes.

 *Reduces redundancy and speeds up development.

3. Encapsulation

   *Data and methods are bundled together within objects.

   *Helps protect data from unauthorized access and unintended changes.

4. Abstraction

   *Hides complex internal implementation and shows only the necessary features.

   *Simplifies usage and reduces complexity for the user.

5. Polymorphism

   *Allows functions and methods to work with different types of objects.

   *Supports flexible and extendable code design.

Q17. What is the difference between a class variable and an instance variable?


Ans:In Python, class variables and instance variables are used to store data, but they differ in scope and behavior.

A class variable is shared across all instances of a class. It is defined outside any method, directly within the class body. Since it is common to every object, changing it using the class name affects all instances. Class variables are typically used for constants or data shared among all objects.

An instance variable, on the other hand, is unique to each object. It is usually defined inside the __init__() method using self, and it holds data specific to that particular instance. Modifying an instance variable affects only that object.

For example, a Dog class might have a class variable species = "Canine" and an instance variable name for each dog's name.

Thus, class variables maintain shared state, while instance variables store object-specific data.

Key Point:

.Changing a class variable affects all objects, unless overridden.

.Changing an instance variable affects only that object.

Q18. What is multiple inheritance in Python?

Ans:Multiple inheritance is a feature in Python where a class can inherit from more than one parent class. This allows the child class to access methods and attributes from multiple sources, promoting flexibility and code reuse.

In Python, multiple inheritance is implemented by specifying multiple base classes in the class definition, separated by commas. For example:

python

Copy

Edit

    class Father:
    def skill(self):
    print("Driving")

    class Mother:
    def skill(self):
    print("Cooking")

    class Child(Father, Mother):
    pass
When a method with the same name exists in both parent classes, Python uses Method Resolution Order (MRO) to decide which method to call. In the example above, Child().skill() will output Driving because Father is listed first.

While multiple inheritance is powerful, it can lead to complex code and conflicts (such as the Diamond Problem) if not managed properly. Python handles such issues using the C3 linearization algorithm for MRO

Q19. Explain the purpose of "_ _str_ _' and'_ _repr_ _ " methods in Python.

Ans:In Python, __str__ and __repr__ are special (dunder) methods that control how objects are represented as strings. They are especially useful for customizing the output of your classes.

The __str__ method is meant to return a user-friendly string representation of the object. It is called when you use the print() function or str() on an object. Its purpose is to provide readable output that makes sense to end users. For example:

python

Copy

Edit

    def __str__(self):
    return f"Person: {self.name}, Age: {self.age}"
The __repr__ method is meant for developers and debugging. It is called when you use repr() or simply type the object in the Python shell. The goal is to return an unambiguous string, ideally one that could be used to recreate the object using eval(). For example:

python

Copy

Edit

    def __repr__(self):
    return f"Person('{self.name}', {self.age})"
If __str__ is not defined, Python falls back to using __repr__. These methods make classes more readable and maintainable by providing meaningful representations instead of default memory addresses. Using them effectively improves logging, debugging, and user interaction with objects.

Q20. What is the significance of the 'super()' function in Python?

Ans:The **super()** function in Python is used to call methods from a parent (super) class. It is especially useful in inheritance, where you want to extend or modify the behavior of a method from the parent class without completely overriding it.

üîç Key Significance:
Access Parent Class Methods
super() allows you to call a method from the parent class without explicitly naming it. This makes code cleaner and more maintainable.

Avoid Hardcoding Class Names
Using super() is more flexible than calling ParentClass.method(self) because it automatically refers to the correct superclass in a class hierarchy.

Supports Multiple Inheritance
In multiple inheritance scenarios, super() works with Method Resolution Order (MRO) to ensure that each parent is called only once and in the correct order.

üß± Example:

python

Copy

Edit

    class Parent:
    def greet(self):
    print("Hello from Parent")

    class Child(Parent):
    def greet(self):
    super().greet()
    print("Hello from Child")

    c = Child()
    c.greet()

    Output:
    csharp
    Hello from Parent  
    Hello from Child

Q21. What is the significance of the _ _del _ _ method¬†in¬†Python?

Ans:The _ _del_ _ method in Python is a special method called a destructor. It is automatically invoked when an object is about to be destroyed or garbage collected. Its main purpose is to perform cleanup actions, such as releasing resources (files, network connections, memory, etc.).

 Key Points:

.Called Automatically

Python calls __del__() when there are no more references to the object.

.Used for Cleanup

Ideal for closing files, releasing memory, or cleaning up before the object is removed from memory.

.Not Always Guaranteed

Python‚Äôs garbage collector may delay or skip calling __del__() if there are circular references or during interpreter shutdown.

üß± Example:
python
Copy
Edit

    class FileHandler:
    def __init__(self, filename):
    self.file = open(filename, 'w')

    def __del__(self):
    print("Closing file...")
    self.file.close()

    f = FileHandler("test.txt")
    del f  # Triggers __del__ and closes the file

Q22. What is the difference between@staticmethod and @classmethod in Python?

Ans:In Python, @staticmethod and @classmethod are decorators used to define special types of methods that differ from regular instance methods.

A @staticmethod is a method that does not take the instance (self) or the class (cls) as its first argument. It behaves just like a normal function but belongs to the class‚Äôs namespace. It cannot access or modify class or instance data. Static methods are typically used for utility functions that are related to the class but don‚Äôt need to access class-specific or object-specific data.

A @classmethod, on the other hand, takes the class itself (cls) as the first argument, instead of self. It can access and modify class-level variables and is often used for factory methods ‚Äî methods that return instances of the class using alternative constructors.

üß± Example:
python
Copy
Edit

    class Demo:
    count = 0

    @staticmethod
    def greet():
    print("Hello!")

    @classmethod
    def increment(cls):
    cls.count += 1
Here, greet() is a utility method, while increment() changes the class variable count.

‚úÖ Summary:
Use @staticmethod when no object/class data is needed. Use @classmethod when class-level access is required.

Q23. How does polymorphism work in Python with inheritance?

Ans:Polymorphism in Python allows objects of different classes to be treated as objects of a common superclass. When used with inheritance, polymorphism enables a child class to override methods of the parent class, while still being accessed through a reference of the parent class type.

 How It Works:

A base class defines a method.

Derived classes override that method with their own implementations.

You can call the method on a base class reference, and the appropriate method from the actual object (child class) is executed.

This behavior is called dynamic (or runtime) method dispatch.

üß± Example:
python
Copy
Edit

    class Animal:
    def speak(self):
    print("Animal speaks")

    class Dog(Animal):
    def speak(self):
    print("Dog barks")

    class Cat(Animal):
    def speak(self):
    print("Cat meows")

# Polymorphic behavior
    def make_animal_speak(animal):
    animal.speak()

    a1 = Dog()
    a2 = Cat()

    make_animal_speak(a1)  # Output: Dog barks
    make_animal_speak(a2)  # Output: Cat meows

Q24. What is method chaining in Python OOP?

Ans:Method chaining in Python OOP is a technique where multiple method calls are made on the same object in a single line, one after another. This is done by having each method return self, so the next method can be called on the same object.

üîç Key Features:
Enhances code readability and fluency

Requires each method to return the object itself (return self)

Common in builder patterns and configuration-style code

üß± Example:
python
Copy
Edit

    class Person:
    def __init__(self, name):
    self.name = name
    self.age = 0
    self.city = ""

    def set_age(self, age):
    self.age = age
    return self  # Enables chaining

    def set_city(self, city):
    self.city = city
    return self  # Enables chaining

    def show(self):
    print(f"{self.name}, {self.age}, {self.city}")
    return self

    # Method chaining
    p = Person("Nishu").set_age(25).set_city("Patna").show()
    Output:
    Nishu, 25, Patna

Q25. What is the purpose of the _ _call _ _ method¬†in¬†Python?

Ans:In Python, the __call__ method is a special (dunder) method that allows an object of a class to be called as if it were a function. When an instance is followed by parentheses (like obj()), Python automatically invokes the instance‚Äôs __call__() method.

The main purpose of __call__ is to give function-like behavior to objects. This is particularly useful when you want objects to perform a specific action when "called" or to maintain state across multiple function calls.

This feature is commonly used in decorators, function wrappers, machine learning models, and configuration builders, where objects behave like functions but can also store internal data.

Example

    class Multiplier:
    def __init__(self, factor):
    self.factor = factor

    def __call__(self, number):
    return number * self.factor

    double = Multiplier(2)
    print(double(5))  # Output: 10

In this example, double is an object, but calling double(5) works like a function due to __call__.

PRACTIAL QUESTION
"""

1. Create a parent class Animal with a method speak) that prints a generic message. Create a child class Dog that overrides the speak) method to print "Bark!".
Ans:

class Animal:
    def speak(self):
        print("Animal speaks")

class Dog(Animal):
    def speak(self):
        print("Bark!")

# Example usage:
animal = Animal()
animal.speak()

dog = Dog()
dog.speak()

Q2. Write a program to create an abstract class Shape with a method area. Derive classes Circle and Rectangle from it and implement the area ) method in both.

Ans
from abc import ABC, abstractmethod
import math

class Shape(ABC):  # Abstract class
    @abstractmethod
    def area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return math.pi * self.radius**2

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

# Example usage:
# shape = Shape() # This would raise an error because Shape is abstract

circle = Circle(5)
print(f"Area of Circle: {circle.area()}")

rectangle = Rectangle(4, 6)
print(f"Area of Rectangle: {rectangle.area()}")

Q3. Implement a multi-level inheritance scenario where a class Vehicle has an attribute type. Derive a class Car and further derive a class ElectricCar that adds a battery attribute.

Ans:
class Vehicle:
    def __init__(self, vehicle_type):
        self.type = vehicle_type

class Car(Vehicle):
    def __init__(self, vehicle_type, model):
        super().__init__(vehicle_type)
        self.model = model

class ElectricCar(Car):
    def __init__(self, vehicle_type, model, battery_capacity):
        super().__init__(vehicle_type, model)
        self.battery = battery_capacity

# Example usage:
my_electric_car = ElectricCar("Car", "Tesla Model S", "100 kWh")

print(f"Vehicle Type: {my_electric_car.type}")
print(f"Model: {my_electric_car.model}")
print(f"Battery Capacity: {my_electric_car.battery}")

Q4. Demonstrate polymorphism by creating a base class Bird with a method fly). Create two derived classes
Sparrow and Penguin that override the fly) method

Ans:
class Bird:
    def fly(self):
        print("Bird is flying")

class Sparrow(Bird):
    def fly(self):
        print("Sparrow is fluttering")

class Penguin(Bird):
    def fly(self):
        print("Penguins can't fly, but they can swim!")

# Demonstrate polymorphism
def make_bird_fly(bird):
    bird.fly()

sparrow = Sparrow()
penguin = Penguin()

make_bird_fly(sparrow)
make_bird_fly(penguin)

Q5. Write a program to demonstrate encapsulation by creating a class BankAccount with private attributes balance and methods to deposit, withdraw, and check balance.

Ans
class BankAccount:
    def __init__(self):
        self.__balance = 0  # Private attribute

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            print(f"Deposited: {amount}. New balance: {self.__balance}")
        else:
            print("Deposit amount must be positive.")

    def withdraw(self, amount):
        if amount > 0:
            if self.__balance >= amount:
                self.__balance -= amount
                print(f"Withdrew: {amount}. New balance: {self.__balance}")
            else:
                print("Insufficient balance.")
        else:
            print("Withdrawal amount must be positive.")

    def get_balance(self):
        return self.__balance

# Example usage:
account = BankAccount()

account.deposit(1000)
account.withdraw(500)
print(f"Current balance: {account.get_balance()}")
account.withdraw(600) # Demonstrates insufficient balance

Q6. Demonstrate runtime polymorphism using a method play) in a base class Instrument. Derive classes Guitar and Piano that implement their own version of play)

Ans:
class Instrument:
    def play(self):
        print("Playing an instrument")

class Guitar(Instrument):
    def play(self):
        print("Strumming the guitar")

class Piano(Instrument):
    def play(self):
        print("Playing the piano keys")

# Demonstrate runtime polymorphism
def make_instrument_play(instrument):
    instrument.play()

guitar = Guitar()
piano = Piano()

make_instrument_play(guitar)
make_instrument_play(piano)

Q7. Create a class MathOperations with a class method add _ numbers () to add two numbers and a static method subtract_numbers) to subtract two numbers.

Ans:
class MathOperations:
    @classmethod
    def add_numbers(cls, num1, num2):
        return num1 + num2

    @staticmethod
    def subtract_numbers(num1, num2):
        return num1 - num2

# Example usage:
sum_result = MathOperations.add_numbers(10, 5)
print(f"Sum: {sum_result}")

difference_result = MathOperations.subtract_numbers(10, 5)
print(f"Difference: {difference_result}")

Q8. Implement a class Person with a class method to count the total number of persons created.

Ans:
class Person:
    count = 0  # Class variable to keep track of the number of persons

    def __init__(self, name):
        self.name = name
        Person.count += 1  # Increment the count whenever a new Person object is created

    @classmethod
    def get_person_count(cls):
        return cls.count

# Example usage:
person1 = Person("Alice")
person2 = Person("Bob")
person3 = Person("Charlie")

print(f"Total number of persons created: {Person.get_person_count()}")

Q9. Write a class Fraction with attributes numerator and denominator. Override the str method to display the fraction as "numerator/denominator*

Ans:
class Fraction:
    def __init__(self, numerator, denominator):
        self.numerator = numerator
        self.denominator = denominator

    def __str__(self):
        return f"{self.numerator}/{self.denominator}"

# Example usage:
fraction1 = Fraction(3, 4)
print(fraction1)

fraction2 = Fraction(1, 2)
print(fraction2)

Q10. Demonstrate operator overloading by creating a class Vector and overriding the add method to add¬†two¬†vectors.

Ans:
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __str__(self):
        return f"Vector({self.x}, {self.y})"

    def __add__(self, other):
        if isinstance(other, Vector):
            return Vector(self.x + other.x, self.y + other.y)
        else:
            raise TypeError("Can only add a Vector object to another Vector object")

# Example usage:
vector1 = Vector(2, 3)
vector2 = Vector(1, 4)

vector3 = vector1 + vector2
print(vector3)

Q11. Create a class Person with attributes name and age. Add a method greet) that prints "Hello, my name is (name} and I am {age) years old."

Ans:
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        print(f"Hello, my name is {self.name} and I am {self.age} years old.")

# Example usage:
person1 = Person("Nishu", 25)
person1.greet()

Q12. Implement a class Student with attributes name and grades. Create a method average_grade()to compute the average of the grades.

Ans:
class Student:
    def __init__(self, name, grades):
        self.name = name
        self.grades = grades

    def average_grade(self):
        if not self.grades:  # Handle case with no grades
            return 0
        return sum(self.grades) / len(self.grades)

# Example usage:
student1 = Student("Nishu", [85, 90, 92, 88])
print(f"{student1.name}'s average grade: {student1.average_grade()}")

student2 = Student("Amit", [])
print(f"{student2.name}'s average grade: {student2.average_grade()}")

Q13.Create a class Rectangle with methods set_dimensions) to set the dimensions and area to calculate the area.

Ans:
class Rectangle:
    def __init__(self):
        self.width = 0
        self.height = 0

    def set_dimensions(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

# Example usage:
rectangle = Rectangle()
rectangle.set_dimensions(10, 5)
print(f"The area of the rectangle is: {rectangle.area()}")

Q14. Create a class Employee with a method calculate _salary that computes the salary based on hours worked and hourly rate. Create a derived class Manager that adds a bonus¬†to¬†the¬†salary.

Ans:
class Employee:
    def __init__(self, hours_worked, hourly_rate):
        self.hours_worked = hours_worked
        self.hourly_rate = hourly_rate

    def calculate_salary(self):
        return self.hours_worked * self.hourly_rate

class Manager(Employee):
    def __init__(self, hours_worked, hourly_rate, bonus):
        super().__init__(hours_worked, hourly_rate)
        self.bonus = bonus

    def calculate_salary(self):
        base_salary = super().calculate_salary()
        return base_salary + self.bonus

# Example usage:
employee = Employee(40, 20)
print(f"Employee salary: {employee.calculate_salary()}")

manager = Manager(40, 20, 500)
print(f"Manager salary: {manager.calculate_salary()}")

Q15. Create a class Product with attributes name, price, and quantity. Implement a method total _price) that calculates the total price of the product

Ans:
class Product:
    def __init__(self, name, price, quantity):
        self.name = name
        self.price = price
        self.quantity = quantity

    def total_price(self):
        return self.price * self.quantity

# Example usage:
product1 = Product("Laptop", 1000, 2)
print(f"Total price for {product1.name}: ${product1.total_price()}")

product2 = Product("Mouse", 25, 5)
print(f"Total price for {product2.name}: ${product2.total_price()}")

Q16. Create a class Animal with an abstract method sound). Create two derived classes Cow and Sheep that implement the sound) method.

Ans:
from abc import ABC, abstractmethod

class Animal(ABC):  # Abstract class
    @abstractmethod
    def sound(self):
        pass

class Cow(Animal):
    def sound(self):
        print("Moo")

class Sheep(Animal):
    def sound(self):
        print("Baa")

# Example usage:
# animal = Animal() # This would raise an error

cow = Cow()
cow.sound()

sheep = Sheep()
sheep.sound()

Q17. Create a class Book with attributes title, author, and year _published. Add a method get _book_info) that returns a formatted string with the book's details

Ans:
class Book:
    def __init__(self, title, author, year_published):
        self.title = title
        self.author = author
        self.year_published = year_published

    def get_book_info(self):
        return f"Title: {self.title}, Author: {self.author}, Year Published: {self.year_published}"

# Example usage:
book1 = Book("The Hitchhiker's Guide to the Galaxy", "Douglas Adams", 1979)
print(book1.get_book_info())

Q18. Create a class House with attributes address and price. Create a derived class Mansion that adds an attribute number_of_rooms.

Ans:
class House:
    def __init__(self, address, price):
        self.address = address
        self.price = price

class Mansion(House):
    def __init__(self, address, price, number_of_rooms):
        super().__init__(address, price)
        self.number_of_rooms = number_of_rooms

# Example usage:
my_mansion = Mansion("123 Luxury Lane", 5000000, 20)
print(f"Mansion Address: {my_mansion.address}")
print(f"Mansion Price: ${my_mansion.price}")
print(f"Number of Rooms: {my_mansion.number_of_rooms}")